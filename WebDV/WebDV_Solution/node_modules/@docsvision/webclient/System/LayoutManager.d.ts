import { $LayoutCardController } from "@docsvision/webclient/Generated/DocsVision.WebClient.Controllers";
import { GenModels } from "@docsvision/webclient/Generated/DocsVision.WebClient.Models";
import { ModalWindow } from "@docsvision/webclient/Legacy/ModalWindow";
import { $ApplicationTimestamp, $Locale, $SiteUrl } from "@docsvision/webclient/StandardServices";
import { ILayout } from '@docsvision/webclient/System/$Layout';
import { Layout } from "@docsvision/webclient/System/Layout";
import { $CardId, $CardTimestamp, $ExtendedDataSourceInfos, $RowId } from '@docsvision/webclient/System/LayoutServices';
import { LayoutContainer } from "@docsvision/webclient/System/LayoutContainer";
import { PageLeaveConfirmation } from '@docsvision/webclient/System/PageLeaveConfirmation';
import { CancelableEvent } from "@docsvision/webclient/System/CancelableEvent";
import { ICancelableEvent } from "@docsvision/webclient/System/ICancelableEvent";
import { IEventArgs } from "@docsvision/webclient/System/IEventArgs";
import { SimpleEvent } from "@docsvision/webclient/System/SimpleEvent";
import { ShowLayoutParams } from "@docsvision/webclient/System/ShowLayoutParams";
import { ILayoutManager } from "@docsvision/webclient/System/$LayoutManager";
import { $Router } from '@docsvision/webclient/System/$Router';
import { ServiceContainer } from "@docsvision/webclient/System/ServiceContainer";
/** @internal */
export declare type $MainContentElementId = {
    mainContentElementId: string;
};
export declare const $MainContentElementId: string | ((model?: $MainContentElementId) => string);
export declare type $LayoutManagerServices = $SiteUrl & $ApplicationTimestamp & $LayoutCardController & $Locale & $CardId & $RowId & $CardTimestamp & $Router & $ExtendedDataSourceInfos;
/** Основной класс для отображения разметок и получения к ним доступа. */
export declare class LayoutManager implements ILayoutManager {
    protected services: $LayoutManagerServices;
    protected layoutContainer?: LayoutContainer<GenModels.LayoutViewModel>;
    protected layoutContainers: LayoutContainer<GenModels.LayoutViewModel>[];
    protected layoutCardLayoutPosition: string;
    protected layoutUnloading: CancelableEvent<ILayout>;
    protected layoutUnloaded: SimpleEvent<ILayout>;
    protected pageLeaveConfirmation: PageLeaveConfirmation;
    private internalMainContentChange;
    protected prevConfirmationModal: ModalWindow;
    /** @internal */
    constructor(services?: $LayoutManagerServices);
    /** Если в данный момент в Web-клиенте открыта карточка, то возвращает ее разметку. */
    readonly cardLayout: Layout | undefined;
    /** Событие, возникающее перед закрытием разметки.  */
    readonly LayoutUnloading: ICancelableEvent<IEventArgs>;
    /** Событие, возникающее после закрытия разметки.  */
    readonly LayoutUnloaded: SimpleEvent<IEventArgs>;
    /** Открывает разметку карточки на месте основного содержимого Web-клиента. */
    showCard(model: GenModels.LayoutCardViewModel, name: string, owner?: string, services?: ServiceContainer): JQueryDeferred<Layout>;
    showRow(model: GenModels.LayoutRowViewModel, name: string, owner?: string, services?: ServiceContainer): JQueryDeferred<Layout>;
    /** Открывает разметку. */
    showLayout({ root, name, model, owner, layoutPosition, services }: ShowLayoutParams): JQueryDeferred<Layout>;
    /** Возвращает разметку по имени экземпляра. */
    getLayout(nameOrId: string): Layout | undefined;
    /** Возвращает имя разметки, заполняющей место основного содержимого Web-клиента. */
    getCurrentLayoutName(): string | undefined;
    /** Возвращает описание разметки по имени экземпляра. */
    getLayoutModel(name: string): GenModels.LayoutViewModel | GenModels.LayoutCardViewModel | GenModels.LayoutRowViewModel | undefined;
    /**
     * Возвращает разметку по id экземпляра.
     * @internal
     */
    getLayoutById(id: string): ILayout | undefined;
    /**
     * Возвращает разметку по HTML элементу.
     * @internal
     */
    getLayoutByHtmlElement(element: HTMLElement): ILayout | undefined;
    /** @internal */
    protected unmountCallback(layoutContainer?: LayoutContainer<GenModels.LayoutViewModel>): void;
    /** @internal */
    protected mountCallback(layoutContainer: LayoutContainer<GenModels.LayoutViewModel>): void;
    /** @internal */
    protected initialize(): void;
    private onMainContentChanging;
    destroyAllUnsaved(showLeaveConfirmationDialog?: boolean): JQueryDeferred<void>;
    deleteAllUnsaved(synchronous?: boolean): JQueryDeferred<any>;
    /** Закрывает разметку с указанным именем экземпляра. */
    destroy(nameOrId?: string, showLeaveConfirmationDialog?: boolean): JQueryDeferred<any>;
    private deleteUnsaved;
    getUnsavedLayouts(): Layout[];
    layoutIsUnsaved(layout: Layout): boolean;
    /** @internal */
    onWindowUnload(): Promise<void>;
    /**
     *  @deprecated
     */
    readonly RootHtmlElement: HTMLElement;
    /**
     *  @deprecated
     */
    readonly IsCardSaved: boolean;
    /**
     * @deprecated Use showLayout instead
     */
    show(root: HTMLElement | string, name: string, model: GenModels.LayoutViewModel): JQueryDeferred<Layout>;
    /** @deprecated Используйте сервис $LayoutCardController метод delete */
    deleteCard(cardId?: string, permanent?: boolean, parentCardId?: string, relatedCreatorCardInfo?: GenModels.RelatedCreatorCardInfo): JQueryDeferred<any>;
    /** @deprecated используйте свойство в LayoutContainer */
    disablePageLeaveConfirmation(): void;
    /**
     * Равносильно нажатию кнопки "Назад" в браузере.
     * @deprecated используйте $RouteNavigation.back
     */
    back(): JQueryDeferred<void>;
    /** @internal */
    protected readonly siteUrl: string;
    /** Временная метка запуска сервера. */
    protected readonly applicationTimestamp: number;
}
export declare let layoutManager: LayoutManager | undefined;
export declare function setLayoutManager(manager: LayoutManager): void;
